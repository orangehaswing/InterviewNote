# 设计模式（6）-装饰者模式

**定义：**

    在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。

    它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。

**角色：**

**    抽象构件角色（Project）：**给出一个接口，以规范准备接收附加责任的对象。

**    具体构件角色（Employe）：**定义一个将要接收附加责任的类。

**    装饰角色（Manager）：**持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。

   ** 具体装饰角色（ManagerA、ManagerB）：**负责给构件对象“贴上”附加的责任。

**示例：**

公共接口：

```
public interface Person {  
    void eat();  
}
```

被装饰对象：

```
public class OldPerson implements Person {  
    @Override  
    public void eat() {  
        System.out.println("吃饭");  
    }  
} 

```

装饰对象：

```
public class NewPerson implements Person {  
    private OldPerson p;  

    NewPerson(OldPerson p) {  
        this.p = p;  
    }  

    @Override  
    public void eat() {  
        System.out.println("生火");  
        System.out.println("做饭");  
        p.eat();  
        System.out.println("刷碗");   
    }  
}  
```

测试：

```
public class PersonDemo {  
    public static void main(String[] args) {  
        OldPerson old = new OldPerson();  
        //old.eat(); 
        NewPerson np = new NewPerson(old);  
        np.eat();  
    }  
} 

```

        通过例子可以看到，没有改变原来的OldPerson类，同时也没有定义他的子类而实现了Person的扩展，这就是装饰者模式的作用。

**优点：**

        1，使用装饰者模式比使用继承更加灵活，因为它选择通过一种动态的方式来扩展一个对象的功能，在运行时可以选择不同的装饰器，从而实现不同的行为。

        2，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。

        3，具体构件类与具体装饰类可以独立变化，他能是低耦合的。用户可以根据需要来增加新的具体构件类和具体装饰类，在使用时再对其进行各种组合，原有代码无须改变，符合“开闭原则”。

 

**缺点：**

        1，会产生很多的小对象，增加了系统的复杂性

        2，这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

 

**装饰者与适配者模式的区别：**

   1，适配器模式主要用来兼容那些不能在一起工作的类，使他们转化为可以兼容目标接口，虽然也可以实现和装饰者一样的增加新职责，但目的不在此。

        装饰者模式主要是给被装饰者增加新职责的。

   2，适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。

        装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。

   3，适配器是知道被适配者的详细情况的（就是那个类或那个接口）。

        装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。

 

**装饰者和继承的区别：**

继承：

　　优点：代码结构清晰，而且实现简单

　　缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。

装饰者：

　　优点：内部可以通过多态技术对多个需要增强的类进行增强

       缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。

**使用场景：**

        1，需要扩展一个类的功能，或给一个类添加附加职责。

        2，需要动态的给一个对象添加功能，这些功能可能不明确或者暂时的，可以随时很方便的动态撤销掉。

        3，需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。

        4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。





